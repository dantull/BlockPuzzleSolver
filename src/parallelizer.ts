import { LabeledShapes, Point } from "./geometry.js";
import { create_solver, Event, PointInspector, Setter, Solver } from "./solver.js";

function split<T>(r:Record<string, T>):[string | undefined, r1:Record<string, T>, r2:Record<string, T>] {
    const r1:Record<string, T> = { };
    const r2:Record<string, T> = { };
    let once = undefined;

    for (const k in r) {
        if (!once) {
            r1[k] = r[k];
            once = k;
        } else {
            r2[k] = r[k];
        }
    }

    return [once, r1, r2];
}

export type SolverConfig = {
    placed: Point[],
    picked: Point[],
    shapes: LabeledShapes,
    board_points: Point[]
};

// given the usual inputs for a Solver, instead pick one shape to place to generate a set of partially solved boards
// and generate a series of data required to continue the computation separately
export function partialSolve(board:Point[], shapes:LabeledShapes, blocked:Point[], inspect:(pi: PointInspector) => void) {
    const [k, first, rest] = split(shapes);

    const solver:Solver = create_solver(board, first, (set:Setter, pi:PointInspector) => {
        blocked.forEach((p) => set(p, "-"));
        inspect(pi);
    });

    return (partialCallback:(sc:SolverConfig) => void) => {
        const remainingShapes = rest;

        const callback = (pi:PointInspector, e:Event) => {
            if (e.kind === "solved") {
                const piece = board.filter(p => pi(p) === k);

                const task:SolverConfig = {
                    placed: piece,
                    picked: blocked,
                    shapes: remainingShapes,
                    board_points: board
                };

                partialCallback(task);
            }
        }

        return solver(callback);
    }
}

// generate a solver to continue the partial solution generated by partialSolve 
export function continueSolve(data:SolverConfig, inspect:(pi:PointInspector) => void):Solver {
    return create_solver(data.board_points, data.shapes, (set:Setter, pi:PointInspector) => {
        data.picked.forEach((p) => set(p, "-"));
        data.placed.forEach((p) => set(p, "!"));

        inspect(pi);
    });
}